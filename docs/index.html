<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Polynomial Root Finder — G–K Method</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
  body {
    font-family: Arial, sans-serif;
    max-width: 900px;
    margin: auto;
    padding: 20px;
  }
  input, button, textarea {
    padding: 6px;
    margin: 5px 0;
    width: 100%;
  }
  canvas {
    margin-top: 30px;
  }
</style>
</head>
<body>

<h1>Polynomial Root Finder — G–K Method</h1>

<h2>Input</h2>
<label>Degree n (≥ 5)</label>
<input id="degree" type="number" value="5">

<label>Coefficients a₀, … , aₙ (comma-separated)</label>
<textarea id="coeffs">-20,6,2,-11,3,-5</textarea>

<button onclick="runDemo()">Run demo</button>

<h2>Result</h2>
<div id="output"></div>

<h2>Convergence comparison</h2>
<canvas id="convergenceChart" width="700" height="400"></canvas>

<script>
function runDemo() {
  const n = parseInt(document.getElementById("degree").value);
  const coeffs = document.getElementById("coeffs").value
    .split(",")
    .map(x => parseFloat(x.trim()));

  if (coeffs.length !== n + 1 || coeffs.some(isNaN)) {
    alert("Please enter exactly n+1 valid coefficients.");
    return;
  }

  function p(x) {
    return coeffs.reduce((s,a,i) => s + a*Math.pow(x,i), 0);
  }
  function dp(x) {
    return coeffs.slice(1)
      .reduce((s,a,i) => s + (i+1)*a*Math.pow(x,i), 0);
  }

  const an = coeffs[n];
  const M = 1 + Math.max(...coeffs.slice(0,n).map(a => Math.abs(a/an)));

  function referenceRoot(x0) {
    let x = x0;
    for (let i=0;i<40;i++) {
      const dfx = dp(x);
      if (Math.abs(dfx) < 1e-10) break;
      x = x - p(x)/dfx;
    }
    return x;
  }

  const x0 = 0.5*M;
  const alpha = referenceRoot(x0);

  function iterateGK(x0,L,N=20) {
    let x=x0, err=[];
    for (let k=0;k<N;k++) {
      err.push(Math.abs(x-alpha));
      x = x + p(x)/L;
    }
    return err;
  }

  function iterateNewton(x0,N=10) {
    let x=x0, err=[];
    for (let k=0;k<N;k++) {
      err.push(Math.abs(x-alpha));
      const dfx = dp(x);
      if (Math.abs(dfx)<1e-10) break;
      x = x - p(x)/dfx;
    }
    return err;
  }

  function iterateBisection(a,b,N=20) {
    let err=[];
    for (let k=0;k<N;k++) {
      const m = 0.5*(a+b);
      err.push(Math.abs(m-alpha));
      if (p(a)*p(m)<=0) b=m; else a=m;
    }
    return err;
  }

  const L = 10*M;
  const errGK      = iterateGK(x0,L);
  const errNewton  = iterateNewton(x0);
  const errBisect  = iterateBisection(0,M);

  document.getElementById("output").innerHTML =
    `Root ≈ ${alpha.toExponential(6)} — Cauchy bound M = ${M.toFixed(4)}`;

  const ctx = document.getElementById("convergenceChart").getContext("2d");
  if (window.chart) window.chart.destroy();

  window.chart = new Chart(ctx,{
    type:"line",
    data:{
      labels: errGK.map((_,i)=>i),
      datasets:[
        {label:"G–K", data: errGK, borderWidth:2},
        {label:"Newton", data: errNewton, borderWidth:2},
        {label:"Bisection", data: errBisect, borderWidth:2}
      ]
    },
    options:{
      scales:{
        y:{ type:"logarithmic", title:{display:true,text:"Error"} },
        x:{ title:{display:true,text:"Iteration"} }
      }
    }
  });
}
</script>

</body>
</html>
